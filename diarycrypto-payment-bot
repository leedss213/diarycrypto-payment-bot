import os
import discord
from discord import app_commands
import midtransclient
import sqlite3
from datetime import datetime, timedelta
from flask import Flask, request, jsonify
import threading
import asyncio

# ==================== CONFIGURATION ====================
TOKEN = os.environ['DISCORD_TOKEN']
GUILD_ID = 1370638839407972423

PACKAGES = {
    "warrior_1month": {
        "name": "The Warrior 1 Month",
        "price": 299000,
        "duration_days": 30,
        "role_id": 1371002371899133992
    },
    "warrior_3month": {
        "name": "The Warrior 3 Months",
        "price": 649000,
        "duration_days": 90,
        "role_id": 1371002371899133992
    }
}

MIDTRANS_SERVER_KEY = os.environ['MIDTRANS_SERVER_KEY']
MIDTRANS_CLIENT_KEY = os.environ['MIDTRANS_CLIENT_KEY']

# ==================== FLASK WEBHOOK SERVER ====================
app = Flask(__name__)


@app.route('/webhook/midtrans', methods=['POST'])
def midtrans_webhook():
    try:
        notification = request.get_json()
        print(f"üì• Webhook received: {notification}")

        order_id = notification.get('order_id')
        transaction_status = notification.get('transaction_status')
        fraud_status = notification.get('fraud_status')

        print(
            f"Order: {order_id}, Status: {transaction_status}, Fraud: {fraud_status}"
        )

        if transaction_status == 'capture':
            if fraud_status == 'accept':
                asyncio.run_coroutine_threadsafe(
                    activate_subscription(order_id), bot.loop)
        elif transaction_status == 'settlement':
            asyncio.run_coroutine_threadsafe(activate_subscription(order_id),
                                             bot.loop)
        elif transaction_status in ['cancel', 'deny', 'expire']:
            print(f"‚ùå Payment {transaction_status} for order {order_id}")

        return jsonify({'status': 'success'}), 200
    except Exception as e:
        print(f"‚ùå Webhook error: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({'status': 'healthy', 'bot': 'running'}), 200


# ==================== BOT SETUP ====================
intents = discord.Intents.default()
intents.members = True
intents.message_content = True

bot = discord.Client(intents=intents)
tree = app_commands.CommandTree(bot)
snap = midtransclient.Snap(is_production=True,
                           server_key=MIDTRANS_SERVER_KEY,
                           client_key=MIDTRANS_CLIENT_KEY)


# ==================== DATABASE SETUP ====================
def init_database():
    conn = sqlite3.connect('warrior_subscriptions.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS subscriptions
                 (discord_id TEXT PRIMARY KEY,
                  package_type TEXT,
                  start_date TIMESTAMP,
                  end_date TIMESTAMP,
                  status TEXT DEFAULT 'active',
                  order_id TEXT)''')
    c.execute('''CREATE TABLE IF NOT EXISTS pending_orders
                 (order_id TEXT PRIMARY KEY,
                  discord_id TEXT,
                  package_type TEXT,
                  duration_days INTEGER,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
    conn.commit()
    conn.close()


def save_pending_order(order_id, discord_id, package_type, duration_days):
    conn = sqlite3.connect('warrior_subscriptions.db')
    c = conn.cursor()
    c.execute(
        '''INSERT OR REPLACE INTO pending_orders 
                 (order_id, discord_id, package_type, duration_days)
                 VALUES (?, ?, ?, ?)''',
        (order_id, discord_id, package_type, duration_days))
    conn.commit()
    conn.close()


def get_pending_order(order_id):
    conn = sqlite3.connect('warrior_subscriptions.db')
    c = conn.cursor()
    c.execute(
        'SELECT discord_id, package_type, duration_days FROM pending_orders WHERE order_id = ?',
        (order_id, ))
    result = c.fetchone()
    conn.close()
    return result


def save_subscription(discord_id, package_type, duration_days, order_id):
    conn = sqlite3.connect('warrior_subscriptions.db')
    c = conn.cursor()
    start_date = datetime.now()
    end_date = start_date + timedelta(days=duration_days)

    c.execute(
        '''INSERT OR REPLACE INTO subscriptions 
                 (discord_id, package_type, start_date, end_date, status, order_id)
                 VALUES (?, ?, ?, ?, 'active', ?)''',
        (discord_id, package_type, start_date, end_date, order_id))

    c.execute('DELETE FROM pending_orders WHERE order_id = ?', (order_id, ))
    conn.commit()
    conn.close()


# ==================== PAYMENT ACTIVATION ====================
async def activate_subscription(order_id):
    try:
        pending = get_pending_order(order_id)
        if not pending:
            print(f"‚ö†Ô∏è No pending order found for {order_id}")
            return

        discord_id, package_type, duration_days = pending
        save_subscription(discord_id, package_type, duration_days, order_id)

        guild = bot.get_guild(GUILD_ID)
        if not guild:
            print(f"‚ùå Guild {GUILD_ID} not found")
            return

        member = guild.get_member(int(discord_id))
        if not member:
            print(f"‚ùå Member {discord_id} not found in guild")
            return

        role_id = PACKAGES[package_type]["role_id"]
        role = guild.get_role(role_id)

        if role:
            await member.add_roles(role)
            print(f"‚úÖ Assigned role {role.name} to {member.name}")

        embed = discord.Embed(
            title="‚úÖ PEMBAYARAN BERHASIL!",
            description=
            f"Selamat! Akses **{PACKAGES[package_type]['name']}** kamu sudah aktif.",
            color=0x00ff00)
        embed.add_field(name="üìÖ Durasi",
                        value=f"{duration_days} hari",
                        inline=True)
        embed.add_field(name="üéØ Status", value="Active", inline=True)
        embed.set_footer(text="Terima kasih telah berlangganan!")

        try:
            await member.send(embed=embed)
        except:
            print(f"‚ö†Ô∏è Could not DM user {discord_id}")

        print(f"‚úÖ Subscription activated for user {discord_id}")

    except Exception as e:
        print(f"‚ùå Error activating subscription: {e}")


# ==================== SLASH COMMANDS ====================
@tree.command(name="buy", description="Beli akses The Warrior")
@app_commands.describe(package="Pilih paket langganan")
@app_commands.choices(package=[
    app_commands.Choice(name="1 Month - Rp 299,000", value="warrior_1month"),
    app_commands.Choice(name="3 Months - Rp 649,000", value="warrior_3month")
])
async def buy_command(interaction: discord.Interaction,
                      package: app_commands.Choice[str]):
    await interaction.response.defer(thinking=True, ephemeral=True)

    try:
        selected_package = PACKAGES[package.value]
        timestamp = int(datetime.now().timestamp())
        order_id = f"W{interaction.user.id}{timestamp}"[-36:]

        transaction = snap.create_transaction({
            "transaction_details": {
                "order_id": order_id,
                "gross_amount": selected_package["price"]
            },
            "item_details": [{
                "id": package.value,
                "price": selected_package["price"],
                "quantity": 1,
                "name": selected_package["name"]
            }],
            "customer_details": {
                "first_name": interaction.user.display_name[:30],
                "email": f"{interaction.user.id}@warrior.diarycrypto"
            }
        })

        payment_url = transaction['redirect_url']
        save_pending_order(order_id, str(interaction.user.id), package.value,
                           selected_package["duration_days"])

        embed = discord.Embed(
            title="üéØ UPGRADE TO THE WARRIOR",
            description=
            f"**Paket:** {selected_package['name']}\n**Harga:** Rp {selected_package['price']:,}\n**Durasi:** {selected_package['duration_days']} hari",
            color=0x00ff00)
        embed.add_field(name="üîó Payment Link",
                        value=f"[Klik di sini untuk bayar]({payment_url})",
                        inline=False)
        embed.add_field(
            name="üí≥ Metode Pembayaran",
            value="‚Ä¢ Transfer Bank\n‚Ä¢ E-Wallet\n‚Ä¢ Kartu Kredit/Debit",
            inline=False)
        embed.set_footer(
            text="Role akan aktif otomatis setelah pembayaran berhasil")

        try:
            await interaction.user.send(embed=embed)
            await interaction.followup.send(
                "‚úÖ Link pembayaran telah dikirim ke DM kamu!", ephemeral=True)
        except discord.Forbidden:
            await interaction.followup.send(embed=embed, ephemeral=True)

    except Exception as e:
        print(f"Payment error: {e}")
        await interaction.followup.send(
            "‚ùå Gagal membuat link pembayaran. Silakan coba lagi.",
            ephemeral=True)


@bot.event
async def on_ready():
    print(f'‚úÖ {bot.user} has connected to Discord!')
    try:
        await tree.sync(guild=discord.Object(id=GUILD_ID))
        print(f"‚úÖ Commands synced to guild {GUILD_ID}")
    except Exception as e:
        print(f"‚ùå Sync error: {e}")
    print("üéâ Bot is ready!")


# ==================== RUN BOT ====================
if __name__ == "__main__":

    def run_flask():
        app.run(host='0.0.0.0', port=5000, debug=False)

    flask_thread = threading.Thread(target=run_flask, daemon=True)
    flask_thread.start()

    init_database()
    print("üöÄ Starting Discord bot...")
    print(
        "üåê Webhook URL will be available at: https://<your-repl-url>/webhook/midtrans"
    )
    bot.run(TOKEN)
